<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: lavaan Options</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for lavOptions {lavaan}"><tr><td>lavOptions {lavaan}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>lavaan Options</h2>

<h3>Description</h3>

<p>Show the default options used by the <code>lavaan()</code> function. The
options can be changed by passing 'name = value' arguments to the 
<code>lavaan()</code> function call, where they will be added to the '...'
argument.
</p>


<h3>Usage</h3>

<pre>
lavOptions(x = NULL, default = NULL, mimic = "lavaan")
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>Character. A character string holding an option name, or a character
string vector holding multiple option names. All option names are converted to
lower case.</p>
</td></tr>
<tr valign="top"><td><code>default</code></td>
<td>
<p>If a single option is specified but not available, this value
is returned.</p>
</td></tr>
<tr valign="top"><td><code>mimic</code></td>
<td>
<p>Character. Adjust the option list for this mimic flag.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the full list of options that are accepted by the <code>lavaan()</code>
function, organized in several sections:
</p>
<p>Model features (always available):
</p>

<dl>
<dt><code>meanstructure</code>:</dt><dd><p>If <code>TRUE</code>, the means of the observed
variables enter the model. If <code>"default"</code>, the value is set based
on the user-specified model, and/or the values of other arguments.</p>
</dd>
<dt><code>int.ov.free</code>:</dt><dd><p>If <code>FALSE</code>, the intercepts of the 
observed variables are fixed to zero.</p>
</dd>
<dt><code>int.lv.free</code>:</dt><dd><p>If <code>FALSE</code>, the intercepts of the latent 
variables are fixed to zero.</p>
</dd>
<dt><code>conditional.x</code>:</dt><dd><p>If <code>TRUE</code>, we set up the model 
conditional on the exogenous &lsquo;x&rsquo; covariates; the model-implied sample 
statistics only include the non-x variables. If <code>FALSE</code>, the 
exogenous &lsquo;x&rsquo; variables are modeled jointly with the other variables, and 
the model-implied statistics refect both sets of variables. If
<code>"default"</code>, the value is set depending on the estimator, and
whether or not the model involves categorical endogenous variables.</p>
</dd>
<dt><code>fixed.x</code>:</dt><dd><p>If <code>TRUE</code>, the exogenous &lsquo;x&rsquo; covariates are 
considered fixed variables and the means, variances and covariances of 
these variables are fixed to their sample values. If <code>FALSE</code>, they 
are considered random, and the means, variances and covariances are free 
parameters. If <code>"default"</code>, the value is set depending on the mimic 
option.</p>
</dd>
<dt><code>orthogonal</code>:</dt><dd><p>If <code>TRUE</code>, all covariances among
latent variables are set to zero.</p>
</dd>
<dt><code>orthogonal.y</code>:</dt><dd><p>If <code>TRUE</code>, all covariances among
endogenous latent variables only are set to zero.</p>
</dd>
<dt><code>orthogonal.x</code>:</dt><dd><p>If <code>TRUE</code>, all covariances among
exogenous latent variables only are set to zero.</p>
</dd>
<dt><code>std.lv</code>:</dt><dd><p>If <code>TRUE</code>, the metric of each latent variable 
is determined by fixing their (residual) variances to 1.0. If 
<code>FALSE</code>, the metric of each latent variable is determined by fixing 
the factor loading of the first indicator to 1.0. If there are multiple
groups, <code>std.lv = TRUE</code> and <code>"loadings"</code> is included in 
the <code>group.label</code> argument, then only the latent variances i
of the first group will be fixed to 1.0, while the latent
variances of other groups are set free.</p>
</dd>
<dt><code>effect.coding</code>:</dt><dd><p>Can be logical or character string. If
logical and <code>TRUE</code>, this implies 
<code>effect.coding = c("loadings", "intercepts")</code>. If logical and 
<code>FALSE</code>, it is set equal to the empty string. 
If <code>"loadings"</code> is included, equality
constraints are used so that the average of the factor loadings (per
latent variable) equals 1. Note that this should not be used 
together with <code>std.lv = TRUE</code>. If <code>"intercepts"</code> is
included, equality constraints are used so that the sum of the
intercepts (belonging to the indicators of a single latent variable) 
equals zero.
As a result, the latent mean will be freely estimated and usually 
equal the average of the means of the involved indicators.</p>
</dd>
<dt><code>parameterization</code>:</dt><dd><p>Currently only used if data is 
categorical. If <code>"delta"</code>, the delta parameterization is used. 
If <code>"theta"</code>, the theta parameterization is used.</p>
</dd>
</dl>

<p>Model features (only available for the <code>lavaan()</code> function):
</p>

<dl>
<dt><code>auto.fix.first</code>:</dt><dd><p>If <code>TRUE</code>, the factor loading of the 
first indicator is set to 1.0 for every latent variable.</p>
</dd>
<dt><code>auto.fix.single</code>:</dt><dd><p>If <code>TRUE</code>, the residual variance (if 
included) of an observed indicator is set to zero if it is the only 
indicator of a latent variable.</p>
</dd>
<dt><code>auto.var</code>:</dt><dd><p>If <code>TRUE</code>, the residual variances and the 
variances of exogenous latent variables are included in the model and 
set free.</p>
</dd>
<dt><code>auto.cov.lv.x</code>:</dt><dd><p>If <code>TRUE</code>, the covariances of exogenous 
latent variables are included in the model and set free.</p>
</dd>
<dt><code>auto.cov.y</code>:</dt><dd><p>If <code>TRUE</code>, the covariances of dependent 
variables (both observed and latent) are included in the model and set 
free.</p>
</dd>
<dt><code>auto.th</code>:</dt><dd><p>If <code>TRUE</code>, thresholds for limited dependent 
variables are included in the model and set free.</p>
</dd>
<dt><code>auto.delta</code>:</dt><dd><p>If <code>TRUE</code>, response scaling parameters 
for limited dependent variables are included in the model and set free.</p>
</dd>
<dt><code>auto.efa</code>:</dt><dd><p>If <code>TRUE</code>, the necessary constraints are
imposed to make the (unrotated) exploratory factor analysis blocks
identifiable: for each block, factor variances are set to 1, factor
covariances are constrained to be zero, and factor loadings are
constrained to follow an echelon pattern.</p>
</dd>
</dl>

<p>Data options:
</p>

<dl>
<dt><code>std.ov</code>:</dt><dd><p>If <code>TRUE</code>, all observed variables are 
standardized before entering the analysis.</p>
</dd>
<dt><code>missing</code>:</dt><dd><p>The default setting is <code>"listwise"</code>: all
cases with missing values
are removed listwise from the data before the analysis starts. This is
only valid if the data are missing completely at random (MCAR).
Therefore, it may not be the optimal choice, but
it can be useful for a first run. If the estimator belongs to
the ML family, another option is <code>"ml"</code> (alias: <code>"fiml"</code>
or <code>"direct"</code>). This corresponds to the so-called full information
maximum likelihood approach (fiml), where we compute the likelihood
case by case, using all available data from that case. Note
that if the model contains exogenous observed covariates, and
<code>fixed.x = TRUE</code> (the default), all cases with any missing values
on these covariates will be deleted first. The option <code>"ml.x"</code>
(alias: <code>"fiml.x"</code> or <code>"direct.x"</code>) is similar to <code>"ml"</code>,
but does not delete any cases with missing values for the exogenous
covariates, even if <code>fixed.x = TRUE</code>. (Note: all lavaan versions
&lt; 0.6 used <code>"ml.x"</code> instead of <code>"ml"</code>).
If you wish to use multiple
imputation, you need to use an external package (eg. mice) to
generate imputed datasets, which can then be analyzed using
the <code><a href="lavaanList.html">semList</a></code> function. The semTools package contains
several functions to do this automatically. Another option (with
continuous data) is to use <code>"two.stage"</code>
or <code>"robust.two.stage"</code>. In this approach, we first estimate
the sample statistics (mean vector, variance-covariance matrix) using
an EM algorithm. Then, we use these estimated sample statistics as
input for a regular analysis (as if the data were complete). The
standard errors and test statistics
are adjusted correctly to reflect the two-step procedure. The
<code>"robust.two.stage"</code> option produces standard errors and
a test statistic that are robust against non-normality.
If (part of) the data is categorical, and the estimator is
from the (W)LS family, the only option (besides listwise deletion)
is <code>"pairwise"</code>. In this three-step approach, missingness is
only an issue in the first two steps. In the first step, we compute
thresholds (for categorical variables) and means or intercepts
(for continuous variables) using univariate information only.
In this step, we simply ignore
the missing values just like in mean(x, na.rm = TRUE). In the second
step, we compute polychoric/polyserial/pearson correlations using (only)
two variables at a time. Here we use pairwise deletion: we only keep
those observations for which both values are observed (not-missing).
And this may change from pair to pair.
By default, in the categorical case we use <code>conditional.x = TRUE</code>. 
Therefore, any cases
with missing values on the exogenous covariates will be deleted listwise
from the data first.
Finally, if the estimator is <code>"PML"</code>, the available options are
<code>"pairwise"</code>, <code>"available.cases"</code> and
<code>"doubly.robust"</code>. See the PML tutorial on the lavaan website for
more information about these approaches.</p>
</dd>
<dt><code>sampling.weights.normalization</code>:</dt><dd><p>If <code>"none"</code>, the
sampling weights (if provided) will not be transformed. If <code>"total"</code>,
the sampling weights are normalized by dividing by the total sum of
the weights, and multiplying again by the total sample size. 
If <code>"group"</code>, the sampling weights are normalized per group:
by dividing by the sum of the weights (in each group), and multiplying
again by the group size. The default is <code>"total"</code>.</p>
</dd>
</dl>

<p>Data summary options:
</p>

<dl>
<dt><code>sample.cov.rescale</code>:</dt><dd><p>If <code>TRUE</code>, the sample covariance 
matrix provided by the user is internally rescaled by multiplying it 
with a factor (N-1)/N.  If <code>"default"</code>, the value is set depending 
on the estimator and the likelihood option: it is set to <code>TRUE</code> if 
maximum likelihood estimation is used and <code>likelihood="normal"</code>, 
and <code>FALSE</code> otherwise.</p>
</dd>
<dt><code>ridge</code>:</dt><dd><p>Numeric. Small constant used for ridging. Only used 
if the sample covariance matrix is non positive definite.</p>
</dd>
</dl>

<p>Multiple group options:
</p>
      
<dl>
<dt><code>group.label</code>:</dt><dd><p>A character vector. The user can specify 
which group (or factor) levels need to be selected from the grouping 
variable, and in which order. If missing, all grouping levels are 
selected, in the order as they appear in the data.</p>
</dd>
<dt><code>group.equal</code>:</dt><dd><p>A vector of character strings. Only used in
a multiple group analysis. Can be one or more of the following:
<code>"loadings"</code>, <code>"composite.loadings"</code>, 
<code>"intercepts"</code>, <code>"means"</code>,
<code>"thresholds"</code>, <code>"regressions"</code>, <code>"residuals"</code>,
<code>"residual.covariances"</code>, <code>"lv.variances"</code> or
<code>"lv.covariances"</code>, specifying the pattern of equality
constraints across multiple groups.</p>
</dd>
<dt><code>group.partial</code>:</dt><dd><p>A vector of character strings containing 
the labels of the parameters which should be free in all groups (thereby
overriding the group.equal argument for some specific parameters).</p>
</dd>
<dt><code>group.w.free</code>:</dt><dd><p>Logical. If <code>TRUE</code>, the group 
frequencies are considered to be free parameters in the model. In this 
case, a Poisson model is fitted to estimate the group frequencies. If
<code>FALSE</code> (the default), the group frequencies are fixed to their
observed values.</p>
</dd>
</dl>

<p>Estimation options:
</p>

<dl>
<dt><code>estimator</code>:</dt><dd><p>The estimator to be used. Can be one of the 
following: <code>"ML"</code> for maximum likelihood, <code>"GLS"</code> for 
(normal theory) generalized least squares, 
<code>"WLS"</code> for weighted least squares 
(sometimes called ADF estimation), <code>"ULS"</code> for unweighted least 
squares, <code>"DWLS"</code> for diagonally weighted least squares,
and <code>"DLS"</code> for distributionally-weighted least squares. These
are the main options that affect the estimation. For convenience, the
<code>"ML"</code> option can be extended as <code>"MLM"</code>, <code>"MLMV"</code>,
<code>"MLMVS"</code>, <code>"MLF"</code>, and <code>"MLR"</code>.
The estimation will still be plain <code>"ML"</code>, but now
with robust standard errors and a robust (scaled) test statistic. For
<code>"MLM"</code>, <code>"MLMV"</code>, <code>"MLMVS"</code>, classic robust standard
errors are used (<code>se="robust.sem"</code>); for <code>"MLF"</code>, standard
errors are based on first-order derivatives 
(<code>information = "first.order"</code>);
for <code>"MLR"</code>, &lsquo;Huber-White&rsquo; robust standard errors are used
(<code>se="robust.huber.white"</code>). In addition, <code>"MLM"</code> will compute
a Satorra-Bentler scaled (mean adjusted) test statistic
(<code>test="satorra.bentler"</code>) , <code>"MLMVS"</code> will compute a
mean and variance adjusted test statistic (Satterthwaite style)
(<code>test="mean.var.adjusted"</code>), <code>"MLMV"</code> will compute a mean
and variance adjusted test statistic (scaled and shifted)
(<code>test="scaled.shifted"</code>), and <code>"MLR"</code> will
compute a test statistic which is asymptotically
equivalent to the Yuan-Bentler T2-star test statistic
(<code>test="yuan.bentler.mplus"</code>). Analogously,
the estimators <code>"WLSM"</code> and <code>"WLSMV"</code> imply the <code>"DWLS"</code>
estimator (not the <code>"WLS"</code> estimator) with robust standard errors
and a mean or mean and variance adjusted test statistic. Estimators
<code>"ULSM"</code> and <code>"ULSMV"</code> imply the <code>"ULS"</code>
estimator with robust standard errors
and a mean or mean and variance adjusted test statistic.</p>
</dd>
<dt><code>likelihood</code>:</dt><dd><p>Only relevant for ML estimation. If 
<code>"wishart"</code>, the wishart likelihood approach is used. In this 
approach, the covariance matrix has been divided by N-1, and both 
standard errors and test statistics are based on N-1.
If <code>"normal"</code>, the normal likelihood approach is used. Here,
the covariance matrix has been divided by N, and both standard errors
and test statistics are based on N. If <code>"default"</code>, it depends
on the mimic option: if <code>mimic="lavaan"</code> or <code>mimic="Mplus"</code>,
normal likelihood is used; otherwise, wishart likelihood is used.</p>
</dd>
<dt><code>link</code>:</dt><dd><p>Currently only used if estimator is MML. 
If <code>"logit"</code>, a logit link is used for binary and ordered observed 
variables. If <code>"probit"</code>, a probit link is used. If 
<code>"default"</code>, it is currently set to <code>"probit"</code> (but this may 
change).</p>
</dd>
<dt><code>information</code>:</dt><dd><p>If <code>"expected"</code>, the expected 
information matrix is used (to compute the standard errors). If 
<code>"observed"</code>, the observed information matrix is used. 
If <code>"first.order"</code>, the information matrix is based on the
outer product of the casewise scores. See also the options
<code>"h1.information"</code> and <code>"observed.information"</code> for
further control. If <code>"default"</code>, the value is set depending 
on the estimator, the missing argument, and the mimic option. If
the argument is a vector with two elements, the first element
is used for the computation of the standard errors, while the
second element is used for the (robust) test statistic.</p>
</dd>
<dt><code>h1.information</code>:</dt><dd><p>If <code>"structured"</code> (the default), the
unrestricted (h1) information part of the (expected, first.order or 
observed if h1 is used) information matrix is based on the structured, 
or model-implied statistics (model-implied covariance matrix, 
model-implied mean vector, etc.). 
If <code>"unstructured"</code>, the unrestricted (h1) information part is
based on sample-based statistics (observed covariance matrix, observed
mean vector, etc.) If
the argument is a vector with two elements, the first element
is used for the computation of the standard errors, while the
second element is used for the (robust) test statistic.</p>
</dd>
<dt><code>observed.information</code>:</dt><dd><p>If <code>"hessian"</code>, the observed
information matrix is based on the hessian of the objective function.
If <code>"h1"</code>, an approximation is used that is based on 
the observed information matrix of the unrestricted (h1) model. If
the argument is a vector with two elements, the first element
is used for the computation of the standard errors, while the
second element is used for the (robust) test statistic.</p>
</dd>
<dt><code>se</code>:</dt><dd><p>If <code>"standard"</code>, conventional standard errors
are computed based on inverting the (expected, observed or first.order) 
information matrix. If <code>"robust.sem"</code>, conventional robust
standard errors are computed.  If <code>"robust.huber.white"</code>,
standard errors are computed based on the &lsquo;mlr&rsquo; (aka pseudo ML,
Huber-White) approach.
If <code>"robust"</code>, either <code>"robust.sem"</code> or
<code>"robust.huber.white"</code> is used depending on the estimator,
the mimic option, and whether the data are complete or not.
If <code>"boot"</code> or <code>"bootstrap"</code>, bootstrap standard errors are
computed using standard bootstrapping (unless Bollen-Stine bootstrapping
is requested for the test statistic; in this case bootstrap standard
errors are computed using model-based bootstrapping).
If <code>"none"</code>, no standard errors are computed.</p>
</dd>
<dt><code>test</code>:</dt><dd><p>If <code>"standard"</code>, a conventional chi-square test 
is computed. If <code>"Satorra.Bentler"</code>, a Satorra-Bentler scaled test 
statistic is computed. If <code>"Yuan.Bentler"</code>, a Yuan-Bentler scaled 
test statistic is computed. If <code>"Yuan.Bentler.Mplus"</code>, a 
test statistic is computed that is asymptotically equal to the
Yuan-Bentler scaled
test statistic. If <code>"mean.var.adjusted"</code> or 
<code>"Satterthwaite"</code>, a mean and variance adjusted test statistic is 
compute. If <code>"scaled.shifted"</code>, an alternative mean and variance 
adjusted test statistic is computed (as in Mplus version 6 or higher).
If <code>"boot"</code> or <code>"bootstrap"</code> or <code>"Bollen.Stine"</code>, the 
Bollen-Stine bootstrap is used to compute the bootstrap probability value 
of the test statistic. If <code>"default"</code>, the value depends on the
values of other arguments. From version 0.6-5 onwards, the test argument
accepts a vector, and therefore multiple tests can be requested.</p>
</dd>
<dt><code>bootstrap</code>:</dt><dd><p>Number of bootstrap draws, if bootstrapping is 
used.</p>
</dd>
<dt><code>do.fit</code>:</dt><dd><p>If <code>FALSE</code>, the model is not fit, and the 
current starting values of the model parameters are preserved.</p>
</dd>
</dl>

<p>Optimization options:
</p>

<dl>
<dt><code>control</code>:</dt><dd><p>A list containing control parameters passed to 
the external optimizer. By default, lavaan uses <code>"nlminb"</code>. 
See the manpage of <code><a href="../../stats/html/nlminb.html">nlminb</a></code> for an overview of the control 
parameters. If another (external) optimizer is selected, see the
manpage for that optimizer to see the possible control parameters.</p>
</dd>
<dt><code>optim.method</code>:</dt><dd><p>Character. The optimizer that should be
used. For unconstrained optimization or models with only linear
equality constraints (i.e., the model syntax
does not include any &quot;==&quot;, &quot;&gt;&quot; or &quot;&lt;&quot; operators),
the available options are <code>"nlminb"</code> (the default), <code>"BFGS"</code>,
<code>"L-BFGS-B"</code>. These are all quasi-newton methods. A basic 
implementation of Gauss-Newton is also available
(<code>optim.method = "GN"</code>). The latter is the default when 
<code>estimator = "DLS"</code>.
For constrained
optimization, the only available option is <code>"nlminb.constr"</code>,
which uses an augmented Lagrangian minimization algorithm.</p>
</dd>
<dt><code>optim.force.converged</code>:</dt><dd><p>Logical. If <code>TRUE</code>, pretend
the model has converged, no matter what.</p>
</dd>
<dt><code>optim.dx.tol</code></dt><dd><p>Numeric. Tolerance used for checking if
the elements of the (unscaled) gradient are all zero (in absolute 
value). The default value is 0.001.</p>
</dd>
<dt><code>optim.gn.tol.x</code>:</dt><dd><p>Numeric. Only used when 
<code>optim.method = "GN"</code>. Optimization stops when
the root mean square of the difference between the old and new
parameter values are smaller than this tolerance value. Default is
<code>1e-05</code> for DLS estimation and <code>1e-07</code> otherwise.</p>
</dd>
<dt><code>optim.gn.iter.max</code>:</dt><dd><p>Integer. Only used when 
<code>optim.method = "GN"</code>. The maximum number of GN iterations. 
The default is 200.</p>
</dd>
</dl>

<p>Categorical estimation options:
</p>

<dl>
<dt><code>zero.add</code>:</dt><dd><p>A numeric vector containing two values. These 
values affect the calculation of polychoric correlations when some 
frequencies in the bivariate table are zero. The first value only 
applies for 2x2 tables. The second value for larger tables. This value 
is added to the zero frequency in the bivariate table. If 
<code>"default"</code>, the value is set depending on the <code>"mimic"</code>
option. By default, lavaan uses <code>zero.add = c(0.5. 0.0)</code>.</p>
</dd>
<dt><code>zero.keep.margins</code>:</dt><dd><p>Logical. This argument only affects 
the computation of polychoric correlations for 2x2 tables with an empty 
cell, and where a value is added to the empty cell. If <code>TRUE</code>, the 
other values of the frequency table are adjusted so that all margins are 
unaffected. If <code>"default"</code>, the value is set depending on the 
<code>"mimic"</code>. The default is <code>TRUE</code>.</p>
</dd>
<dt><code>zero.cell.warn</code>:</dt><dd><p>Logical. Only used if some observed 
endogenous variables are categorical. If <code>TRUE</code>, give a warning if 
one or more cells of a bivariate frequency table are empty.</p>
</dd>
</dl>

<p>Starting values options:
</p>

<dl>
<dt><code>start</code>:</dt><dd><p>If it is a character string, the two options are 
currently <code>"simple"</code> and <code>"Mplus"</code>. In the first case, all 
parameter values are set to zero, except the factor loadings and
(residual) variances, which are set to one.
When <code>start</code> is <code>"Mplus"</code>, the factor loadings are
estimated using the fabin3 estimator (tsls) per factor. The
residual variances of observed variables are set tot half the 
observed variance, and all other (residual) variances are set to 0.05.
The remaining parameters (regression coefficients, covariances) are
set to zero.
If <code>start</code> is a fitted object of class <code><a href="lavaan-class.html">lavaan</a></code>,
the estimated values of the corresponding parameters will be extracted.
If it is a parameter table, for example the output of the
<code>paramaterEstimates()</code> function, the values of the <code>est</code> or
<code>start</code> or <code>ustart</code> column (whichever is found first) will be
extracted.</p>
</dd>
</dl>

<p>Check options:
</p>

<dl>
<dt><code>check.start</code>:</dt><dd><p>Logical. If <code>TRUE</code>,
the starting values are checked for possibly 
inconsistent values (for example values implying correlations larger 
than one). If needed, a warning is given.</p>
</dd>
<dt><code>check.gradient</code>:</dt><dd><p>Logical. If <code>TRUE</code>, and the model
converged, a warning
is given if the optimizer decided that a (local) solution has
been found, while not all elements of the (unscaled) gradient (as 
seen by the optimizer) are (near) zero, as
they should be (the tolerance used is 0.001).</p>
</dd>
<dt><code>check.post</code>:</dt><dd><p>Logical. If <code>TRUE</code>, and the model
converged, a check is performed after (post) fitting, to verify if 
the solution is admissable. This implies that all variances are
non-negative, and all the model-implied covariance matrices are 
positive (semi-)definite. For the latter test, we tolerate a tiny 
negative eigenvalue that is smaller than .Machine$double.eps^(3/4), 
treating it as being zero.</p>
</dd>
<dt><code>check.vcov</code>:</dt><dd><p>Logical. If <code>TRUE</code>, and the model converged,
we check if the variance-covariance matrix of the free parameters
is positive definite. We take into account possible equality and
acitive inequality constraints. If needed, a warning is given.</p>
</dd>
<dt><code>check.lv.names</code>:</dt><dd><p>Logical. If <code>TRUE</code>, and latent variables
are defined in the model, lavaan will stop with an error message if
a latent variable name also occurs in the data (implying it is also
an observed variable).</p>
</dd>
</dl>

<p>Verbosity options:
</p>

<dl>
<dt><code>verbose</code>:</dt><dd><p>If <code>TRUE</code>, the function value is printed out 
during each iteration.</p>
</dd>
<dt><code>warn</code>:</dt><dd><p>If <code>TRUE</code>, some (possibly harmless) warnings 
are printed out during the iterations.</p>
</dd>
<dt><code>debug</code>:</dt><dd><p>If <code>TRUE</code>, debugging information is printed 
out.</p>
</dd>
</dl>

<p>Miscellaneous:
</p>

<dl>
<dt><code>model.type</code>:</dt><dd><p>Set the model type: possible values
are <code>"cfa"</code>, <code>"sem"</code> or <code>"growth"</code>. This may affect
how starting values are computed, and may be used to alter the terminology
used in the summary output, or the layout of path diagrams that are
based on a fitted lavaan object.</p>
</dd>
<dt><code>mimic</code>:</dt><dd><p>If <code>"Mplus"</code>, an attempt is made to mimic the 
Mplus program. If <code>"EQS"</code>, an attempt is made to mimic the EQS 
program. If <code>"default"</code>, the value is (currently) set to to 
<code>"lavaan"</code>, which is very close to <code>"Mplus"</code>.</p>
</dd>
<dt><code>representation</code>:</dt><dd><p>If <code>"LISREL"</code> the classical LISREL 
matrix representation is used to represent the model (using the all-y 
variant). No other options are available (for now).</p>
</dd>
<dt><code>implied</code>:</dt><dd><p>Logical. If <code>TRUE</code>, compute the model-implied
statistics, and store them in the implied slot.</p>
</dd>
<dt><code>h1</code>:</dt><dd><p>Logical. If <code>TRUE</code>, compute the unrestricted model
and store the unrestricted summary statistics (and perhaps a 
loglikelihood) in the h1 slot.</p>
</dd>
<dt><code>baseline:</code></dt><dd><p>Logical. If <code>TRUE</code>, compute a baseline model
(currently always the independence model, assuming all variables
are uncorrelated) and store the results in the baseline slot.</p>
</dd>
<dt><code>baseline.conditional.x.free.slopes</code>:</dt><dd><p>Logical. If <code>TRUE</code>,
and <code>conditional.x = TRUE</code>, the (default) baseline model will
allow the slopestructure to be unrestricted.</p>
</dd>
<dt><code>store.vcov</code></dt><dd><p>Logical. If <code>TRUE</code>, and <code>se=</code> is not
set to <code>"none"</code>, store the full variance-covariance matrix of
the model parameters in the vcov slot of the fitted lavaan object.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="lavaan.html">lavaan</a></code>
</p>


<h3>Examples</h3>

<pre>
lavOptions()
lavOptions("std.lv")
lavOptions(c("std.lv", "orthogonal"))
</pre>

<hr /><div style="text-align: center;">[Package <em>lavaan</em> version 0.6-8 <a href="00Index.html">Index</a>]</div>
</body></html>
