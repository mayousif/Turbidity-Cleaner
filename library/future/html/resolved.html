<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Check whether a future is resolved or not</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for resolved {future}"><tr><td>resolved {future}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Check whether a future is resolved or not</h2>

<h3>Description</h3>

<p>Check whether a future is resolved or not
</p>


<h3>Usage</h3>

<pre>
resolved(x, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <a href="Future-class.html">Future</a>, a list, or an environment (which also
includes <a href="../../listenv/html/listenv.html">list environment</a>.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method needs to be implemented by the class that implement
the Future API.  The implementation should return either TRUE or FALSE
and must never throw an error (except for <a href="FutureCondition.html">FutureError</a>:s which indicate
significant, often unrecoverable infrastructure problems).
It should also be possible to use the method for polling the
future until it is resolved (without having to wait infinitely long),
e.g. <code>while (!resolved(future)) Sys.sleep(5)</code>.
</p>


<h3>Value</h3>

<p>A logical of the same length and dimensions as <code>x</code>.
Each element is TRUE unless the corresponding element is a
non-resolved future in case it is FALSE.
</p>

<hr /><div style="text-align: center;">[Package <em>future</em> version 1.21.0 <a href="00Index.html">Index</a>]</div>
</body></html>
